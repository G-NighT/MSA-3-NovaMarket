### **Название задачи:**

Реализация сценария «Просмотр истории покупок» в NovaMarket

### **Автор:**

Минлигареев Максим

### **Дата:**

25.11.2025

---

### **Функциональные требования**

| **№** | **Действующие лица или системы** | **Use Case**                 | **Описание**                                                                                                                                                                                 |
| :---: | :------------------------------- | :--------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   1   | Покупатель                       | Просмотр списка всех заказов | Пользователь открывает раздел «Мои заказы» в мобильном приложении и видит список всех своих заказов с датой, суммой и статусом.                                                              |
|   2   | Покупатель                       | Просмотр деталей заказа      | Пользователь выбирает заказ из списка и видит подробную информацию: состав заказа (товары, количество, цены), итоговую сумму, способ доставки и оплаты, финальный статус заказа, трек-номер. |
|   3   | Покупатель                       | Скачивание чека              | В деталях заказа пользователь может скачать фискальный/платёжный чек (по ссылке, сгенерированной внешним или внутренним сервисом чеков).                                                     |
|   4   | Покупатель                       | Оставить отзыв на товар      | Из деталей заказа пользователь переходит к созданию отзыва на купленные товары (интеграция с существующим сервисом отзывов/каталога).                                                        |
|   5   | Покупатель                       | Повторить заказ              | Пользователь может создать новый заказ на основе прежнего состава (товары добавляются в корзину одним действием).                                                                            |

---

### **Нефункциональные требования**

| **№** | **Требование**                                                                                                                                                               |
| :---: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   1   | Время отклика всех операций пользовательского интерфейса (список заказов, детали заказа) — не более 1 секунды в 99.99% запросов, целевое время 0.3 секунды для 98% запросов. |
|   2   | Решение должно масштабироваться до нагрузки 40 000+ заказов в день и большого количества чтений истории заказов без деградации SLA по отклику.                               |
|   3   | Архитектура должна сохранять слабую связанность микросервисов и опираться на событийное взаимодействие (EDA) через Kafka.                                                    |
|   4   | История заказов должна быть консистентна с основными доменными данными по заказу, оплате и доставке. Допускается eventual consistency в пределах нескольких секунд.          |
|   5   | Решение не должно требовать серьёзной переработки существующих бизнес-сервисов (Order, Payment, Delivery), чтобы минимизировать time-to-market.                              |
|   6   | Хранилище истории заказов должно быть оптимизировано под чтение с возможностью индексации по пользователю, дате, статусу.                                                    |

---

### **Решение**

**Выбранный паттерн:**

Для реализации сценария «Просмотр истории покупок» выбран паттерн **CQRS** с выделением отдельной read-модели и read-сервиса для истории заказов. Командная часть (создание/изменение заказа, оплата, доставка) остаётся в существующих сервисах (**Order Service, Payment Service, Delivery Service**), а чтение агрегированных данных происходит из нового **Order History Query Service**.

**Ключевые идеи:**

1. **Order History Query Service (read-сервис)**

   - Подписывается на доменные события из Kafka-топиков `order-events`, `payment-events`, `delivery-events`.
   - Реагирует на события `OrderCreated`, `OrderStatusChanged`, `OrderCompleted`, `OrderCancelled`, `PaymentSucceeded`, `PaymentFailed`, `PaymentRefunded`, `ShipmentCreated`, `ShipmentStatusUpdated` и др.
   - На основе потока событий строит и поддерживает денормализованную read-модель в `Order History Read DB`, где одна запись соответствует одному заказу пользователя и содержит все необходимые для фронтенда агрегированные данные.
   - Read-модель содержит: идентификатор заказа, дату создания, сумму, список позиций (товар, количество, цена на момент покупки), статус, информацию об оплате, информации о доставке (тип, адрес, трек-номер), ссылки на чек и на отзывы.

2. **Отдельное хранилище для чтения (read-store)**

   - Используется БД (SQL или NoSQL) с денормализованной схемой, оптимизированной под чтение по ключам `userId`, `orderId`, а также фильтрацию по дате и статусу.
   - Обновление хранилища выполняется асинхронно обработчиками событий Order History Query Service.
   - Чтение из истории выполняется одним или двумя простыми запросами, что обеспечивает быстрое время отклика.

3. **Интеграция с фронтендом (API Composition на стороне BFF/Gateway не используется)**

   - Мобильное приложение обращается к одному REST-эндпоинту `/me/orders` и `/me/orders/{orderId}` через API Gateway (NGINX).
   - Gateway маршрутизирует запросы напрямую в Order History Query Service.
   - Фронтенду не нужно вызывать несколько микросервисов и собирать ответ вручную, вся агрегация выполняется на стороне read-сервиса.

4. **Использование событийной архитектуры (EDA)**

   - Существующие сервисы (Order, Payment, Delivery) уже публикуют доменные события в Kafka.
   - Order History Query Service использует их как источник истины для построения read-модели, не внося изменений в контракт и логику этих сервисов.
   - При появлении в будущем новых сервисов (например, Loyalty, Fraud, Recommendation) они также смогут подписаться на те же события без изменения текущего решения.

5. **Соответствие функциональным и нефункциональным требованиям**
   - Время отклика достигается за счёт одного быстрого запроса к денормализованному хранилищу, без цепочек синхронных вызовов между микросервисами.
   - Масштабирование обеспечивается возможностью горизонтально масштабировать Order History Query Service и его read-БД независимо от командной части.
   - Eventual consistency в пределах нескольких секунд считается допустимой: пользователь видит историю заказа чуть позже, но при этом SLA по отзывчивости интерфейса выдерживается.

**Диаграммы:**

- Обновлённая контейнерная C2-диаграмма — см. файл `1. C2-NovaMarket-OrderHistory.puml` в каталоге Task2.
- На ней отражены:
  - новый Order History Query Service и его read-БД;
  - подписка на события из Kafka-топиков заказов, платежей и доставки;
  - взаимодействие мобильного приложения с этим сервисом через API Gateway.

---

### **Альтернативы**

1. **Прямой API Composition через API Gateway / BFF**

   - История заказов формируется в рантайме путём последовательных/параллельных вызовов `Order Service`, `Payment Service`, `Delivery Service`, `Catalog Service` и, возможно, `Review Service`.
   - Gateway или отдельный BFF агрегирует ответы и отдаёт их на фронт.

   **Плюсы:**

   - Простота реализации на старте (без дополнительного read-хранилища).
   - Нет необходимости в отдельной read-модели и обработчиках событий.

   **Минусы:**

   - Высокая задержка ответа: цепочка из нескольких сетевых вызовов с возможной деградацией каждого сервиса по времени/доступности. Сложнее гарантировать SLA 0.3–1 с.
   - Сильная связность BFF/Gateway со всеми доменными сервисами — при изменении контрактов нужно синхронно обновлять агрегатор.
   - Усложнение логики ретраев и деградации (частичный ответ, отсутствие статуса доставки и т.п.).

2. **Event Sourcing для домена заказов с построением проекций**

   - Хранить полный поток событий по заказам, платежам и доставке в виде источника истины и строить проекции для истории заказов.

   **Плюсы:**

   - Полный аудит и возможность «прокрутки» истории для восстановления состояния.
   - Проекции могут использоваться не только для истории заказов, но и для аналитики, отчётности и т.п.

   **Минусы:**

   - Существенное усложнение доменной модели и инфраструктуры, необходимость переосмысления существующих сервисов.
   - Нецелесообразно вводить полноценный Event Sourcing только ради одной функции просмотра истории в MVP.

---

### **Недостатки, ограничения, риски**

1. **Eventual consistency**

   - Пользователь может на короткое время не видеть только что созданный заказ или обновлённый статус, пока событие не обработано read-сервисом.
   - Это необходимо явно задокументировать и учесть в UX (например, вся информация появляется спустя секунду, а не мгновенно).

2. **Сложность поддержки read-модели**

   - Нужно поддерживать обработчики событий и миграции схемы read-БД при изменении доменных событий.
   - При изменении контракта события требуется откат/миграция данных в хранилище истории.

3. **Дополнительные инфраструктурные компоненты**

   - Появляется ещё один сервис и база данных, которые нужно мониторить, масштабировать, резервировать и бэкапить.
   - Необходимо обеспечить идемпотентность обработчиков событий, чтобы избегать дублирования записей при повторной доставке сообщений Kafka.

4. **Риски качества входящих данных**

   - Если какой-то сервис публикует некорректные события (например, статус заказа не соответствует фактическому состоянию), это ошибочное состояние будет отражено и в истории заказов.
   - Требуется тщательное тестирование потоков событий и договорённости о формате доменных событий между командами.

5. **Временные ограничения MVP**
   - В рамках MVP можно ограничить объём агрегируемых данных в read-модели (например, не включать детальные логи по всем статусам доставки), чтобы быстрее вывести функцию в прод и затем расширять модель постепенно.

---
